<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>My Places Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <style>
    body { margin: 0; padding: 0; }
    #map { height: 90vh; }
    #controls { padding: 8px; font-family: sans-serif; }
    select, input, button { margin-right: 8px; }
  </style>
</head>
<body>
  <div id="controls">
    Category:
    <select id="categoryFilter">
      <option value="">All</option>
    </select>
    Min rating:
    <input type="number" id="minRating" step="0.1" min="0" max="5" value="0">
    <button id="applyFilters">Apply filters</button>
  </div>
  <div id="map"></div>

  <!-- Leaflet JS -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin="">
  </script>

  <!-- Papa Parse for CSV -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <script>
    // 1) Point this at your live CSV
    // CSV columns: name,category,rating,google_maps_url[,lat,lng]
    const CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vRNfKG3v-7ATgwAUWo-4P_ASP-_nEL0Azv1TWTRMoPwbIYhWNTsNMDaso7kF7t2jh27McbUaMu6hdQs/pub?output=csv";

    // 2) Extract lat/lng from Google Maps URL when needed
    function extractLatLngFromUrl(url) {
      if (!url) return null;
      try {
        const u = new URL(url);

        // Pattern 1: .../@lat,lng,zoom...
        const atMatch = u.href.match(/@(-?\d+(\.\d+)?),(-?\d+(\.\d+)?)/);
        if (atMatch) {
          return {
            lat: parseFloat(atMatch[1]),
            lng: parseFloat(atMatch[3])
          };
        }

        // Pattern 2: ...?q=lat,lng
        const q = u.searchParams.get("q");
        if (q) {
          const qm = q.match(/(-?\d+(\.\d+)?),\s*(-?\d+(\.\d+)?)/);
          if (qm) {
            return {
              lat: parseFloat(qm[1]),
              lng: parseFloat(qm[3])
            };
          }
        }

        // Pattern 3: coordinates embedded as @lat,lng without decimals (fallback)
        const atMatch2 = u.href.match(/@(-?\d+),(-?\d+)/);
        if (atMatch2) {
          return {
            lat: parseFloat(atMatch2[1]),
            lng: parseFloat(atMatch2[2])
          };
        }

        return null;
      } catch (e) {
        return null;
      }
    }

    let map;
    let markers = [];
    let places = [];

    function initMap() {
      map = L.map('map').setView([22.2819, 114.1580], 13);

      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; OpenStreetMap contributors'
      }).addTo(map);
    }

    function createMarkers() {
      // Clear existing
      markers.forEach(m => {
        if (map.hasLayer(m)) map.removeLayer(m);
      });
      markers = [];

      places.forEach(p => {
        if (p.lat == null || p.lng == null || isNaN(p.lat) || isNaN(p.lng)) return;

        const marker = L.marker([p.lat, p.lng]).addTo(map);
        marker.placeData = p;
        marker.bindPopup(
          `<b>${p.name}</b><br>` +
          `Category: ${p.category ?? ""}<br>` +
          `Rating: ${p.rating ?? ""}<br>` +
          (p.google_maps_url
            ? `<a href="${p.google_maps_url}" target="_blank">Open in Google Maps</a>`
            : "")
        );
        markers.push(marker);
      });

      // Optionally fit map to markers
      if (markers.length > 0) {
        const group = L.featureGroup(markers);
        map.fitBounds(group.getBounds().pad(0.1));
      }
    }

    function populateCategoryFilter() {
      const categorySelect = document.getElementById('categoryFilter');
      // Clear existing besides "All"
      categorySelect.innerHTML = '<option value="">All</option>';

      const categories = [...new Set(places.map(p => p.category).filter(Boolean))].sort();
      categories.forEach(cat => {
        const opt = document.createElement('option');
        opt.value = cat;
        opt.textContent = cat;
        categorySelect.appendChild(opt);
      });
    }

    function applyFilters() {
      const categorySelect = document.getElementById('categoryFilter');
      const selectedCategory = categorySelect.value;
      const minRating = parseFloat(document.getElementById('minRating').value) || 0;

      markers.forEach(m => {
        const p = m.placeData;
        const ratingVal = parseFloat(p.rating) || 0;
        const catOK = !selectedCategory || p.category === selectedCategory;
        const ratingOK = ratingVal >= minRating;

        if (catOK && ratingOK) {
          if (!map.hasLayer(m)) m.addTo(map);
        } else {
          if (map.hasLayer(m)) map.removeLayer(m);
        }
      });
    }

    document.getElementById('applyFilters').addEventListener('click', applyFilters);

    function loadCsvAndRender() {
      Papa.parse(CSV_URL, {
        download: true,
        header: true,
        dynamicTyping: true,
        complete: function(results) {
          places = results.data
            .filter(row => row && row.name) // basic sanity
            .map(row => {
              let lat = row.lat;
              let lng = row.lng;

              if ((lat == null || lng == null || lat === "" || lng === "") && row.google_maps_url) {
                const coords = extractLatLngFromUrl(row.google_maps_url);
                if (coords) {
                  lat = coords.lat;
                  lng = coords.lng;
                }
              }

              return {
                name: row.name,
                category: row.category,
                rating: row.rating,
                google_maps_url: row.google_maps_url,
                lat: typeof lat === "string" ? parseFloat(lat) : lat,
                lng: typeof lng === "string" ? parseFloat(lng) : lng
              };
            });

          populateCategoryFilter();
          createMarkers();
        }
      });
    }

    initMap();
    loadCsvAndRender();

    // Optional periodic poll for updated CSV:
    // setInterval(loadCsvAndRender, 5 * 60 * 1000);
  </script>
</body>
</html>
